<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>001</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>
    <a-scene embedded arjs='sourceType: webcam; debugUIEnabled: false;'>
        <a-assets>
            <a-asset-item id="ring-model" src="assets/ring.glb"></a-asset-item>
        </a-assets>
        <a-entity camera></a-entity>
        <a-entity id="ring" gltf-model="#ring-model" position="0 0 0" scale="0.01 0.01 0.01"></a-entity>
    </a-scene>
    <canvas id="outputCanvas" style="position: fixed; top: 0; left: 0;"></canvas>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const videoElement = document.createElement('video');
            const canvasElement = document.getElementById('outputCanvas');
            const canvasCtx = canvasElement.getContext('2d');
            
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            hands.onResults((results) => {
                canvasCtx.save();
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
                
                if (results.multiHandLandmarks) {
                    for (const landmarks of results.multiHandLandmarks) {
                        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 5});
                        drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 2});
                        
                        // Update the ring position
                        const middleFingerTip = landmarks[12]; // Assuming landmark 12 is the tip of the middle finger
                        const ring = document.getElementById('ring');
                        ring.setAttribute('position', `${middleFingerTip.x * canvasElement.width} ${middleFingerTip.y * canvasElement.height} 0`);
                    }
                }
                canvasCtx.restore();
            });

            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 1280,
                height: 720
            });
            camera.start();
        });

        function drawLandmarks(ctx, landmarks, style = {}) {
            ctx.fillStyle = style.color || 'red';
            for (const landmark of landmarks) {
                ctx.beginPath();
                ctx.arc(landmark.x * ctx.canvas.width, landmark.y * ctx.canvas.height, style.lineWidth || 5, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        function drawConnectors(ctx, landmarks, connections, style = {}) {
            ctx.beginPath();
            ctx.strokeStyle = style.color || 'green';
            ctx.lineWidth = style.lineWidth;
            for (const [startIdx, endIdx] of connections) {
                const start = landmarks[startIdx];
                const end = landmarks[endIdx];
                ctx.moveTo(start.x * ctx.canvas.width, start.y * ctx.canvas.height);
                ctx.lineTo(end.x * ctx.canvas.width, end.y * ctx.canvas.height);
            }
            ctx.stroke();
        }
    </script>
</body>
</html>
