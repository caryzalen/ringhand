<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>01</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://threejs.org/build/three.js"></script>
</head>
<body>
    <div id="loading">Loading...</div>
    <a-scene embedded arjs='sourceType: webcam; debugUIEnabled: false;' style="display: none;">
        <a-entity camera></a-entity>
    </a-scene>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const scene = document.querySelector('a-scene').object3D; // 获取A-Frame场景的Three.js对象
            initializeApp();

            async function initializeApp() {
                try {
                    const ringMesh = await loadModel('assets/ring_model.glb');
                    scene.add(ringMesh);
                    initHandTracking(ringMesh);
                    document.getElementById('loading').style.display = 'none';
                    document.querySelector('a-scene').style.display = 'block';
                } catch (error) {
                    document.getElementById('loading').textContent = 'Failed to load model: ' + error.message;
                }
            }

            function loadModel(url) {
                return new Promise((resolve, reject) => {
                    const loader = new THREE.GLTFLoader();
                    loader.load(url,
                        gltf => resolve(gltf.scene),
                        undefined,
                        error => reject(error)
                    );
                });
            }

            function initHandTracking(ringMesh) {
                const hands = new Hands({
                    locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
                });
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                const videoElement = document.createElement('video');
                const camera = new Camera(videoElement, {
                    onFrame: async () => {
                        try {
                            await hands.send({ image: videoElement });
                        } catch (error) {
                            console.error('Failed to send image to MediaPipe:', error);
                        }
                    },
                    width: 1280,
                    height: 720
                });
                camera.start();
                hands.onResults(results => {
                    if (results.multiHandLandmarks) {
                        updateRingPosition(results.multiHandLandmarks[0], ringMesh);
                    }
                });
            }

            function updateRingPosition(handLandmarks, ringMesh) {
                const baseJointIndex = 9; // 无名指的基部关节
                const tipJointIndex = 12; // 无名指的尖端关节
                if (!handLandmarks || handLandmarks.length <= tipJointIndex) {
                    console.error('Hand landmarks data is insufficient.');
                    return;
                }

                const baseJoint = handLandmarks[baseJointIndex];
                const tipJoint = handLandmarks[tipJointIndex];

                const fingerMidX = (baseJoint.x + tipJoint.x) / 2;
                const fingerMidY = (baseJoint.y + tipJoint.y) / 2;
                const fingerMidZ = (baseJoint.z + tipJoint.z) / 2;

                ringMesh.position.set(fingerMidX, fingerMidY, fingerMidZ);

                const fingerDiameter = Math.sqrt(
                    Math.pow(tipJoint.x - baseJoint.x, 2) +
                    Math.pow(tipJoint.y - baseJoint.y, 2) +
                    Math.pow(tipJoint.z - baseJoint.z, 2)
                );
                ringMesh.scale.set(fingerDiameter, fingerDiameter, fingerDiameter);

                const direction = new THREE.Vector3(
                    tipJoint.x - baseJoint.x,
                    tipJoint.y - baseJoint.y,
                    tipJoint.z - baseJoint.z
                ).normalize();

                const defaultOrientation = new THREE.Vector3(0, 0, 1);
                const quaternion = new THREE.Quaternion().setFromUnitVectors(defaultOrientation, direction);
                ringMesh.quaternion.copy(quaternion);
            }
        });
    </script>
</body>
</html>
